/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core Unknown.
* Used org.franca.core Unknown.
*
* 
*/
#include "PlayerDBusStubAdapter.h"
#include <org/genivi/mediamanager/Player.h>

namespace org {
namespace genivi {
namespace mediamanager {

std::shared_ptr<CommonAPI::DBus::DBusStubAdapter> createPlayerDBusStubAdapter(
                   const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
                   const std::string& commonApiAddress,
                   const std::string& interfaceName,
                   const std::string& busName,
                   const std::string& objectPath,
                   const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyConnection,
                   const std::shared_ptr<CommonAPI::StubBase>& stubBase) {
    return std::make_shared<PlayerDBusStubAdapter>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection, stubBase);
}

INITIALIZER(registerPlayerDBusStubAdapter) {
    CommonAPI::DBus::DBusFactory::registerAdapterFactoryMethod(Player::getInterfaceId(),
                                                               &createPlayerDBusStubAdapter);
}



PlayerDBusStubAdapterInternal::~PlayerDBusStubAdapterInternal() {
    deactivateManagedInstances();
    PlayerDBusStubAdapterHelper::deinit();
}

void PlayerDBusStubAdapterInternal::deactivateManagedInstances() {

}

const char* PlayerDBusStubAdapterInternal::getMethodsDBusIntrospectionXmlData() const {
    static const std::string introspectionData =
        "<method name=\"getInterfaceVersion\">\n"
            "<arg name=\"value\" type=\"uu\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"getMuteAttribute\">\n"
            "<arg name=\"value\" type=\"i\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"setMuteAttribute\">\n"
            "<arg name=\"requestedValue\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"setValue\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        "<signal name=\"onMuteAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"i\" />\n"
        "</signal>\n"
        "<method name=\"getShuffleAttribute\">\n"
            "<arg name=\"value\" type=\"i\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"setShuffleAttribute\">\n"
            "<arg name=\"requestedValue\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"setValue\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        "<signal name=\"onShuffleAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"i\" />\n"
        "</signal>\n"
        "<method name=\"getRepeatAttribute\">\n"
            "<arg name=\"value\" type=\"i\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"setRepeatAttribute\">\n"
            "<arg name=\"requestedValue\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"setValue\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        "<signal name=\"onRepeatAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"i\" />\n"
        "</signal>\n"
        "<method name=\"getRateAttribute\">\n"
            "<arg name=\"value\" type=\"d\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"setRateAttribute\">\n"
            "<arg name=\"requestedValue\" type=\"d\" direction=\"in\" />\n"
            "<arg name=\"setValue\" type=\"d\" direction=\"out\" />\n"
        "</method>\n"
        "<signal name=\"onRateAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"d\" />\n"
        "</signal>\n"
        "<method name=\"getVolumeAttribute\">\n"
            "<arg name=\"value\" type=\"d\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"setVolumeAttribute\">\n"
            "<arg name=\"requestedValue\" type=\"d\" direction=\"in\" />\n"
            "<arg name=\"setValue\" type=\"d\" direction=\"out\" />\n"
        "</method>\n"
        "<signal name=\"onVolumeAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"d\" />\n"
        "</signal>\n"
        "<method name=\"getCanGoNextAttribute\">\n"
            "<arg name=\"value\" type=\"b\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onCanGoNextAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"b\" />\n"
        "</signal>\n"
        "<method name=\"getCanGoPreviousAttribute\">\n"
            "<arg name=\"value\" type=\"b\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onCanGoPreviousAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"b\" />\n"
        "</signal>\n"
        "<method name=\"getCanPauseAttribute\">\n"
            "<arg name=\"value\" type=\"b\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onCanPauseAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"b\" />\n"
        "</signal>\n"
        "<method name=\"getCanPlayAttribute\">\n"
            "<arg name=\"value\" type=\"b\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onCanPlayAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"b\" />\n"
        "</signal>\n"
        "<method name=\"getCanSeekAttribute\">\n"
            "<arg name=\"value\" type=\"b\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onCanSeekAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"b\" />\n"
        "</signal>\n"
        "<method name=\"getCurrentTrackAttribute\">\n"
            "<arg name=\"value\" type=\"t\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onCurrentTrackAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"t\" />\n"
        "</signal>\n"
        "<method name=\"getPlaybackStatusAttribute\">\n"
            "<arg name=\"value\" type=\"i\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onPlaybackStatusAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"i\" />\n"
        "</signal>\n"
        "<method name=\"getPositionAttribute\">\n"
            "<arg name=\"value\" type=\"t\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"getDurationAttribute\">\n"
            "<arg name=\"value\" type=\"t\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onDurationAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"t\" />\n"
        "</signal>\n"
        /**
         * Skip to the next track in the play queue. If there is no
                              
         *  next track, playback is stopped. If playback is paused or
                            
         *    stopped, this function will set the next plack to be
                              
         *  played once playback is activated
         */
        "<method name=\"next\">\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Open the supplied Uri for playback in the playback engine.
                 returns:
         *  INVALID_URI When an invalid URI is supplied
                                      
         *  (decided by playback engine)
                           NO_ERROR    On success
         * @param uri URI of media to play, uri format is decided by backend
         */
        "<method name=\"openUri\">\n"
            "<arg name=\"uri\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Enqueue the supplied Uri for playback in the playback engine.
                 returns:
         *  INVALID_URI When an invalid URI is supplied
                                      
         *  (decided by playback engine)
                          NO_ERROR    On success
         * @param uri URI of media to enqueue, uri format is decided by backend
         */
        "<method name=\"enqueueUri\">\n"
            "<arg name=\"uri\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Dequeue the item with the supplied index in the playback
                             
         *  engine.
         * @param pos index of media to dequeue
         */
        "<method name=\"dequeueIndex\">\n"
            "<arg name=\"pos\" type=\"t\" direction=\"in\" />\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Retrieve the current play queue in JSON format
                 returns: Current play
         *  queue in JSON format
         */
        "<method name=\"getCurrentPlayQueue\">\n"
            "<arg name=\"playQueue\" type=\"s\" direction=\"out\" />\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Dequeue all elements, emptying the play queue
         */
        "<method name=\"dequeueAll\">\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Use the supplied playlist as the current play queue. If
                             
         *  the play queue is invalid, the old play queue is
                             
         *  untouched.
                 returns: BAD_PLAYLIST If playlist can not be loaded
              
         *              NO_ERROR     On success
         */
        "<method name=\"openPlaylist\">\n"
            "<arg name=\"uri\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Pause playback in the playback engine.
                               If already
         *  paused, this has no effect
                               Note: If CanPause is false,
         *  this has no effect
         */
        "<method name=\"pause\">\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Start or resume playback in the playback engine.
                               If
         *  playback is already commencing, this has not effect.
                               If
         *  paused, playback resumes from the current position.
                               If
         *  there is no track to play, calling this has no effect
                              
         *  Note: If CanPlay is false, this has no effect
         */
        "<method name=\"play\">\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Starts playback (see Play) if paused
                              Pauses playback (see
         *  Pause) is playing
         */
        "<method name=\"playPause\">\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Loads previous track in play queue
                              If there is no
         *  previous track, playback is stopped
                              If playback is
         *  stopped or paused, it remains this way,
                              but the next
         *  track to be played will the set
                              by this function
               
         *                Note: If CanGoPrevious is false, this has no effect
         */
        "<method name=\"previous\">\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Seek relatively in the current track
                              If a negative seek
         *  leads to a play position less than 0,
                              the play position
         *  will be set to 0.
                              If a positive seek leads outside the
         *  length of the current
                              track, this is treated like a call
         *  to Next()
                              Note: If CanSeek is false, this has no effect
         * @param pos Relative seek amount in microseconds
         */
        "<method name=\"seek\">\n"
            "<arg name=\"pos\" type=\"x\" direction=\"in\" />\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Jump to the specified position in the current
                               If the
         *  position is not within range of the current track,
                               do
         *  nothing
                 Note: If CanSeek is false, this has no effect
         * @param pos Absolute position in microseconds
         */
        "<method name=\"setPosition\">\n"
            "<arg name=\"pos\" type=\"t\" direction=\"in\" />\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"

    ;
    return introspectionData.c_str();
}

CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        CommonAPI::Version
        > PlayerDBusStubAdapterInternal::getPlayerInterfaceVersionStubDispatcher(&PlayerStub::getInterfaceVersion, "uu");

/**
 * Mute or unmute audio. When muted, the player backend will
                     
 *  not produce any audio output.
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        PlayerTypes::MuteStatus
        > PlayerDBusStubAdapterInternal::getMuteAttributeStubDispatcher(&PlayerStub::getMuteAttribute, "i");
CommonAPI::DBus::DBusSetObservableAttributeStubDispatcher<
        PlayerStub,
        PlayerTypes::MuteStatus
        > PlayerDBusStubAdapterInternal::setMuteAttributeStubDispatcher(
                &PlayerStub::getMuteAttribute,
                &PlayerStubRemoteEvent::onRemoteSetMuteAttribute,
                &PlayerStubRemoteEvent::onRemoteMuteAttributeChanged
                ,&PlayerStubAdapter::fireMuteAttributeChanged
                ,"i"
                );
/**
 * Shuffle or unshuffle the current play queue. Shuffling,
                  
 *  un-shuffling and then re-shuffling will yield two different
                  
 *  shufflings (which are not guaranteed to be different)
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        PlayerTypes::ShuffleStatus
        > PlayerDBusStubAdapterInternal::getShuffleAttributeStubDispatcher(&PlayerStub::getShuffleAttribute, "i");
CommonAPI::DBus::DBusSetObservableAttributeStubDispatcher<
        PlayerStub,
        PlayerTypes::ShuffleStatus
        > PlayerDBusStubAdapterInternal::setShuffleAttributeStubDispatcher(
                &PlayerStub::getShuffleAttribute,
                &PlayerStubRemoteEvent::onRemoteSetShuffleAttribute,
                &PlayerStubRemoteEvent::onRemoteShuffleAttributeChanged
                ,&PlayerStubAdapter::fireShuffleAttributeChanged
                ,"i"
                );
/**
 * Toggle repeat for the current playlist. If enabled,
                     
 *  playback will continue with the first item of the current
                    
 *   play queue when the last item has finished playing
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        PlayerTypes::RepeatStatus
        > PlayerDBusStubAdapterInternal::getRepeatAttributeStubDispatcher(&PlayerStub::getRepeatAttribute, "i");
CommonAPI::DBus::DBusSetObservableAttributeStubDispatcher<
        PlayerStub,
        PlayerTypes::RepeatStatus
        > PlayerDBusStubAdapterInternal::setRepeatAttributeStubDispatcher(
                &PlayerStub::getRepeatAttribute,
                &PlayerStubRemoteEvent::onRemoteSetRepeatAttribute,
                &PlayerStubRemoteEvent::onRemoteRepeatAttributeChanged
                ,&PlayerStubAdapter::fireRepeatAttributeChanged
                ,"i"
                );
/**
 * Set the playback rate
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        double
        > PlayerDBusStubAdapterInternal::getRateAttributeStubDispatcher(&PlayerStub::getRateAttribute, "d");
CommonAPI::DBus::DBusSetObservableAttributeStubDispatcher<
        PlayerStub,
        double
        > PlayerDBusStubAdapterInternal::setRateAttributeStubDispatcher(
                &PlayerStub::getRateAttribute,
                &PlayerStubRemoteEvent::onRemoteSetRateAttribute,
                &PlayerStubRemoteEvent::onRemoteRateAttributeChanged
                ,&PlayerStubAdapter::fireRateAttributeChanged
                ,"d"
                );
/**
 * Get or set volume, 0 is muted, and 1.0 means maximum
                     
 *  volume. Values outside this range will be capped
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        double
        > PlayerDBusStubAdapterInternal::getVolumeAttributeStubDispatcher(&PlayerStub::getVolumeAttribute, "d");
CommonAPI::DBus::DBusSetObservableAttributeStubDispatcher<
        PlayerStub,
        double
        > PlayerDBusStubAdapterInternal::setVolumeAttributeStubDispatcher(
                &PlayerStub::getVolumeAttribute,
                &PlayerStubRemoteEvent::onRemoteSetVolumeAttribute,
                &PlayerStubRemoteEvent::onRemoteVolumeAttributeChanged
                ,&PlayerStubAdapter::fireVolumeAttributeChanged
                ,"d"
                );
/**
 * Indicates whether Next() is available
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        bool
        > PlayerDBusStubAdapterInternal::getCanGoNextAttributeStubDispatcher(&PlayerStub::getCanGoNextAttribute, "b");
/**
 * Indicates whether Previous() is available
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        bool
        > PlayerDBusStubAdapterInternal::getCanGoPreviousAttributeStubDispatcher(&PlayerStub::getCanGoPreviousAttribute, "b");
/**
 * Indicates whether Pause() is available
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        bool
        > PlayerDBusStubAdapterInternal::getCanPauseAttributeStubDispatcher(&PlayerStub::getCanPauseAttribute, "b");
/**
 * Indicates whether Play() is available
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        bool
        > PlayerDBusStubAdapterInternal::getCanPlayAttributeStubDispatcher(&PlayerStub::getCanPlayAttribute, "b");
/**
 * Indicates whether Seek and SetPosition() are available
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        bool
        > PlayerDBusStubAdapterInternal::getCanSeekAttributeStubDispatcher(&PlayerStub::getCanSeekAttribute, "b");
/**
 * Indicates the index in the play queue of the currently
                     
 *  playing track
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        uint64_t
        > PlayerDBusStubAdapterInternal::getCurrentTrackAttributeStubDispatcher(&PlayerStub::getCurrentTrackAttribute, "t");
/**
 * Indicates current playback status
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        PlayerTypes::PlaybackStatus
        > PlayerDBusStubAdapterInternal::getPlaybackStatusAttributeStubDispatcher(&PlayerStub::getPlaybackStatusAttribute, "i");
/**
 * Indicates current position in the currently playing
                      track
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        uint64_t
        > PlayerDBusStubAdapterInternal::getPositionAttributeStubDispatcher(&PlayerStub::getPositionAttribute, "t");
/**
 * Indicates duration of the current track
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        uint64_t
        > PlayerDBusStubAdapterInternal::getDurationAttributeStubDispatcher(&PlayerStub::getDurationAttribute, "t");


/**
 * Skip to the next track in the play queue. If there is no
                      
 *  next track, playback is stopped. If playback is paused or
                    
 *    stopped, this function will set the next plack to be
                      
 *  played once playback is activated
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<>,
    std::tuple<PlayerTypes::PlayerError>
    > PlayerDBusStubAdapterInternal::nextStubDispatcher(&PlayerStub::next, "i");
/**
 * Open the supplied Uri for playback in the playback engine.
         returns:
 *  INVALID_URI When an invalid URI is supplied
                              
 *  (decided by playback engine)
                   NO_ERROR    On success
 * @param uri URI of media to play, uri format is decided by backend
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<std::string>,
    std::tuple<PlayerTypes::PlayerError>
    > PlayerDBusStubAdapterInternal::openUriStubDispatcher(&PlayerStub::openUri, "i");
/**
 * Enqueue the supplied Uri for playback in the playback engine.
         returns:
 *  INVALID_URI When an invalid URI is supplied
                              
 *  (decided by playback engine)
                  NO_ERROR    On success
 * @param uri URI of media to enqueue, uri format is decided by backend
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<std::string>,
    std::tuple<PlayerTypes::PlayerError>
    > PlayerDBusStubAdapterInternal::enqueueUriStubDispatcher(&PlayerStub::enqueueUri, "i");
/**
 * Dequeue the item with the supplied index in the playback
                     
 *  engine.
 * @param pos index of media to dequeue
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<uint64_t>,
    std::tuple<PlayerTypes::PlayerError>
    > PlayerDBusStubAdapterInternal::dequeueIndexStubDispatcher(&PlayerStub::dequeueIndex, "i");
/**
 * Retrieve the current play queue in JSON format
         returns: Current play
 *  queue in JSON format
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<>,
    std::tuple<std::string, PlayerTypes::PlayerError>
    > PlayerDBusStubAdapterInternal::getCurrentPlayQueueStubDispatcher(&PlayerStub::getCurrentPlayQueue, "si");
/**
 * Dequeue all elements, emptying the play queue
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<>,
    std::tuple<PlayerTypes::PlayerError>
    > PlayerDBusStubAdapterInternal::dequeueAllStubDispatcher(&PlayerStub::dequeueAll, "i");
/**
 * Use the supplied playlist as the current play queue. If
                     
 *  the play queue is invalid, the old play queue is
                     
 *  untouched.
         returns: BAD_PLAYLIST If playlist can not be loaded
      
 *              NO_ERROR     On success
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<std::string>,
    std::tuple<PlayerTypes::PlayerError>
    > PlayerDBusStubAdapterInternal::openPlaylistStubDispatcher(&PlayerStub::openPlaylist, "i");
/**
 * Pause playback in the playback engine.
                       If already
 *  paused, this has no effect
                       Note: If CanPause is false,
 *  this has no effect
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<>,
    std::tuple<PlayerTypes::PlayerError>
    > PlayerDBusStubAdapterInternal::pauseStubDispatcher(&PlayerStub::pause, "i");
/**
 * Start or resume playback in the playback engine.
                       If
 *  playback is already commencing, this has not effect.
                       If
 *  paused, playback resumes from the current position.
                       If
 *  there is no track to play, calling this has no effect
                      
 *  Note: If CanPlay is false, this has no effect
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<>,
    std::tuple<PlayerTypes::PlayerError>
    > PlayerDBusStubAdapterInternal::playStubDispatcher(&PlayerStub::play, "i");
/**
 * Starts playback (see Play) if paused
                      Pauses playback (see
 *  Pause) is playing
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<>,
    std::tuple<PlayerTypes::PlayerError>
    > PlayerDBusStubAdapterInternal::playPauseStubDispatcher(&PlayerStub::playPause, "i");
/**
 * Loads previous track in play queue
                      If there is no
 *  previous track, playback is stopped
                      If playback is
 *  stopped or paused, it remains this way,
                      but the next
 *  track to be played will the set
                      by this function
       
 *                Note: If CanGoPrevious is false, this has no effect
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<>,
    std::tuple<PlayerTypes::PlayerError>
    > PlayerDBusStubAdapterInternal::previousStubDispatcher(&PlayerStub::previous, "i");
/**
 * Seek relatively in the current track
                      If a negative seek
 *  leads to a play position less than 0,
                      the play position
 *  will be set to 0.
                      If a positive seek leads outside the
 *  length of the current
                      track, this is treated like a call
 *  to Next()
                      Note: If CanSeek is false, this has no effect
 * @param pos Relative seek amount in microseconds
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<int64_t>,
    std::tuple<PlayerTypes::PlayerError>
    > PlayerDBusStubAdapterInternal::seekStubDispatcher(&PlayerStub::seek, "i");
/**
 * Jump to the specified position in the current
                       If the
 *  position is not within range of the current track,
                       do
 *  nothing
         Note: If CanSeek is false, this has no effect
 * @param pos Absolute position in microseconds
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<uint64_t>,
    std::tuple<PlayerTypes::PlayerError>
    > PlayerDBusStubAdapterInternal::setPositionStubDispatcher(&PlayerStub::setPosition, "i");


/**
 * Mute or unmute audio. When muted, the player backend will
                     
 *  not produce any audio output.
 */
void PlayerDBusStubAdapterInternal::fireMuteAttributeChanged(const PlayerTypes::MuteStatus& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::MuteStatus>>
        ::sendSignal(
            *this,
            "onMuteAttributeChanged",
            "i",
            value
    );
}
/**
 * Shuffle or unshuffle the current play queue. Shuffling,
                  
 *  un-shuffling and then re-shuffling will yield two different
                  
 *  shufflings (which are not guaranteed to be different)
 */
void PlayerDBusStubAdapterInternal::fireShuffleAttributeChanged(const PlayerTypes::ShuffleStatus& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::ShuffleStatus>>
        ::sendSignal(
            *this,
            "onShuffleAttributeChanged",
            "i",
            value
    );
}
/**
 * Toggle repeat for the current playlist. If enabled,
                     
 *  playback will continue with the first item of the current
                    
 *   play queue when the last item has finished playing
 */
void PlayerDBusStubAdapterInternal::fireRepeatAttributeChanged(const PlayerTypes::RepeatStatus& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::RepeatStatus>>
        ::sendSignal(
            *this,
            "onRepeatAttributeChanged",
            "i",
            value
    );
}
/**
 * Set the playback rate
 */
void PlayerDBusStubAdapterInternal::fireRateAttributeChanged(const double& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<double>>
        ::sendSignal(
            *this,
            "onRateAttributeChanged",
            "d",
            value
    );
}
/**
 * Get or set volume, 0 is muted, and 1.0 means maximum
                     
 *  volume. Values outside this range will be capped
 */
void PlayerDBusStubAdapterInternal::fireVolumeAttributeChanged(const double& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<double>>
        ::sendSignal(
            *this,
            "onVolumeAttributeChanged",
            "d",
            value
    );
}
/**
 * Indicates whether Next() is available
 */
void PlayerDBusStubAdapterInternal::fireCanGoNextAttributeChanged(const bool& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<bool>>
        ::sendSignal(
            *this,
            "onCanGoNextAttributeChanged",
            "b",
            value
    );
}
/**
 * Indicates whether Previous() is available
 */
void PlayerDBusStubAdapterInternal::fireCanGoPreviousAttributeChanged(const bool& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<bool>>
        ::sendSignal(
            *this,
            "onCanGoPreviousAttributeChanged",
            "b",
            value
    );
}
/**
 * Indicates whether Pause() is available
 */
void PlayerDBusStubAdapterInternal::fireCanPauseAttributeChanged(const bool& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<bool>>
        ::sendSignal(
            *this,
            "onCanPauseAttributeChanged",
            "b",
            value
    );
}
/**
 * Indicates whether Play() is available
 */
void PlayerDBusStubAdapterInternal::fireCanPlayAttributeChanged(const bool& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<bool>>
        ::sendSignal(
            *this,
            "onCanPlayAttributeChanged",
            "b",
            value
    );
}
/**
 * Indicates whether Seek and SetPosition() are available
 */
void PlayerDBusStubAdapterInternal::fireCanSeekAttributeChanged(const bool& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<bool>>
        ::sendSignal(
            *this,
            "onCanSeekAttributeChanged",
            "b",
            value
    );
}
/**
 * Indicates the index in the play queue of the currently
                     
 *  playing track
 */
void PlayerDBusStubAdapterInternal::fireCurrentTrackAttributeChanged(const uint64_t& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<uint64_t>>
        ::sendSignal(
            *this,
            "onCurrentTrackAttributeChanged",
            "t",
            value
    );
}
/**
 * Indicates current playback status
 */
void PlayerDBusStubAdapterInternal::firePlaybackStatusAttributeChanged(const PlayerTypes::PlaybackStatus& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlaybackStatus>>
        ::sendSignal(
            *this,
            "onPlaybackStatusAttributeChanged",
            "i",
            value
    );
}
/**
 * Indicates duration of the current track
 */
void PlayerDBusStubAdapterInternal::fireDurationAttributeChanged(const uint64_t& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<uint64_t>>
        ::sendSignal(
            *this,
            "onDurationAttributeChanged",
            "t",
            value
    );
}



const PlayerDBusStubAdapterHelper::StubDispatcherTable& PlayerDBusStubAdapterInternal::getStubDispatcherTable() {
    return stubDispatcherTable_;
}

const CommonAPI::DBus::StubAttributeTable& PlayerDBusStubAdapterInternal::getStubAttributeTable() {
    return stubAttributeTable_;
}

PlayerDBusStubAdapterInternal::PlayerDBusStubAdapterInternal(
        const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
        const std::string& commonApiAddress,
        const std::string& dbusInterfaceName,
        const std::string& dbusBusName,
        const std::string& dbusObjectPath,
        const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusConnection,
        const std::shared_ptr<CommonAPI::StubBase>& stub):
        CommonAPI::DBus::DBusStubAdapter(
                factory,
                commonApiAddress,
                dbusInterfaceName,
                dbusBusName,
                dbusObjectPath,
                dbusConnection,
                false),
        PlayerDBusStubAdapterHelper(
            factory,
            commonApiAddress,
            dbusInterfaceName,
            dbusBusName,
            dbusObjectPath,
            dbusConnection,
            std::dynamic_pointer_cast<PlayerStub>(stub),
            false),
        stubDispatcherTable_({
            /**
             * Mute or unmute audio. When muted, the player backend will
                                 
             *  not produce any audio output.
             */
            { { "getMuteAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getMuteAttributeStubDispatcher }
            , { { "setMuteAttribute", "i" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::setMuteAttributeStubDispatcher },
            /**
             * Shuffle or unshuffle the current play queue. Shuffling,
                              
             *  un-shuffling and then re-shuffling will yield two different
                              
             *  shufflings (which are not guaranteed to be different)
             */
            { { "getShuffleAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getShuffleAttributeStubDispatcher }
            , { { "setShuffleAttribute", "i" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::setShuffleAttributeStubDispatcher },
            /**
             * Toggle repeat for the current playlist. If enabled,
                                 
             *  playback will continue with the first item of the current
                                
             *   play queue when the last item has finished playing
             */
            { { "getRepeatAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getRepeatAttributeStubDispatcher }
            , { { "setRepeatAttribute", "i" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::setRepeatAttributeStubDispatcher },
            /**
             * Set the playback rate
             */
            { { "getRateAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getRateAttributeStubDispatcher }
            , { { "setRateAttribute", "d" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::setRateAttributeStubDispatcher },
            /**
             * Get or set volume, 0 is muted, and 1.0 means maximum
                                 
             *  volume. Values outside this range will be capped
             */
            { { "getVolumeAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getVolumeAttributeStubDispatcher }
            , { { "setVolumeAttribute", "d" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::setVolumeAttributeStubDispatcher },
            /**
             * Indicates whether Next() is available
             */
            { { "getCanGoNextAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getCanGoNextAttributeStubDispatcher },
            /**
             * Indicates whether Previous() is available
             */
            { { "getCanGoPreviousAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getCanGoPreviousAttributeStubDispatcher },
            /**
             * Indicates whether Pause() is available
             */
            { { "getCanPauseAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getCanPauseAttributeStubDispatcher },
            /**
             * Indicates whether Play() is available
             */
            { { "getCanPlayAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getCanPlayAttributeStubDispatcher },
            /**
             * Indicates whether Seek and SetPosition() are available
             */
            { { "getCanSeekAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getCanSeekAttributeStubDispatcher },
            /**
             * Indicates the index in the play queue of the currently
                                 
             *  playing track
             */
            { { "getCurrentTrackAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getCurrentTrackAttributeStubDispatcher },
            /**
             * Indicates current playback status
             */
            { { "getPlaybackStatusAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getPlaybackStatusAttributeStubDispatcher },
            /**
             * Indicates current position in the currently playing
                                  track
             */
            { { "getPositionAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getPositionAttributeStubDispatcher },
            /**
             * Indicates duration of the current track
             */
            { { "getDurationAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getDurationAttributeStubDispatcher }
            ,
            /**
             * Skip to the next track in the play queue. If there is no
                                  
             *  next track, playback is stopped. If playback is paused or
                                
             *    stopped, this function will set the next plack to be
                                  
             *  played once playback is activated
             */
            { { "next", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::nextStubDispatcher },
            /**
             * Open the supplied Uri for playback in the playback engine.
                     returns:
             *  INVALID_URI When an invalid URI is supplied
                                          
             *  (decided by playback engine)
                               NO_ERROR    On success
             * @param uri URI of media to play, uri format is decided by backend
             */
            { { "openUri", "s" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::openUriStubDispatcher },
            /**
             * Enqueue the supplied Uri for playback in the playback engine.
                     returns:
             *  INVALID_URI When an invalid URI is supplied
                                          
             *  (decided by playback engine)
                              NO_ERROR    On success
             * @param uri URI of media to enqueue, uri format is decided by backend
             */
            { { "enqueueUri", "s" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::enqueueUriStubDispatcher },
            /**
             * Dequeue the item with the supplied index in the playback
                                 
             *  engine.
             * @param pos index of media to dequeue
             */
            { { "dequeueIndex", "t" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::dequeueIndexStubDispatcher },
            /**
             * Retrieve the current play queue in JSON format
                     returns: Current play
             *  queue in JSON format
             */
            { { "getCurrentPlayQueue", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getCurrentPlayQueueStubDispatcher },
            /**
             * Dequeue all elements, emptying the play queue
             */
            { { "dequeueAll", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::dequeueAllStubDispatcher },
            /**
             * Use the supplied playlist as the current play queue. If
                                 
             *  the play queue is invalid, the old play queue is
                                 
             *  untouched.
                     returns: BAD_PLAYLIST If playlist can not be loaded
                  
             *              NO_ERROR     On success
             */
            { { "openPlaylist", "s" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::openPlaylistStubDispatcher },
            /**
             * Pause playback in the playback engine.
                                   If already
             *  paused, this has no effect
                                   Note: If CanPause is false,
             *  this has no effect
             */
            { { "pause", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::pauseStubDispatcher },
            /**
             * Start or resume playback in the playback engine.
                                   If
             *  playback is already commencing, this has not effect.
                                   If
             *  paused, playback resumes from the current position.
                                   If
             *  there is no track to play, calling this has no effect
                                  
             *  Note: If CanPlay is false, this has no effect
             */
            { { "play", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::playStubDispatcher },
            /**
             * Starts playback (see Play) if paused
                                  Pauses playback (see
             *  Pause) is playing
             */
            { { "playPause", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::playPauseStubDispatcher },
            /**
             * Loads previous track in play queue
                                  If there is no
             *  previous track, playback is stopped
                                  If playback is
             *  stopped or paused, it remains this way,
                                  but the next
             *  track to be played will the set
                                  by this function
                   
             *                Note: If CanGoPrevious is false, this has no effect
             */
            { { "previous", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::previousStubDispatcher },
            /**
             * Seek relatively in the current track
                                  If a negative seek
             *  leads to a play position less than 0,
                                  the play position
             *  will be set to 0.
                                  If a positive seek leads outside the
             *  length of the current
                                  track, this is treated like a call
             *  to Next()
                                  Note: If CanSeek is false, this has no effect
             * @param pos Relative seek amount in microseconds
             */
            { { "seek", "x" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::seekStubDispatcher },
            /**
             * Jump to the specified position in the current
                                   If the
             *  position is not within range of the current track,
                                   do
             *  nothing
                     Note: If CanSeek is false, this has no effect
             * @param pos Absolute position in microseconds
             */
            { { "setPosition", "t" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::setPositionStubDispatcher }
            }),
        stubAttributeTable_() {

    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getPlayerInterfaceVersionStubDispatcher });
}

const bool PlayerDBusStubAdapterInternal::hasFreedesktopProperties() {
    return false;
}

} // namespace mediamanager
} // namespace genivi
} // namespace org
