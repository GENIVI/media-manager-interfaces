/*
* This file was generated by the CommonAPI Generators. 
* Used org.genivi.commonapi.core 2.1.4.
* Used org.franca.core 0.8.9.
*
* 
*/
#include "PlayerDBusStubAdapter.h"
#include <org/genivi/mediamanager/Player.h>

namespace org {
namespace genivi {
namespace mediamanager {

std::shared_ptr<CommonAPI::DBus::DBusStubAdapter> createPlayerDBusStubAdapter(
                   const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
                   const std::string& commonApiAddress,
                   const std::string& interfaceName,
                   const std::string& busName,
                   const std::string& objectPath,
                   const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyConnection,
                   const std::shared_ptr<CommonAPI::StubBase>& stubBase) {
    return std::make_shared<PlayerDBusStubAdapter>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection, stubBase);
}

__attribute__((constructor)) void registerPlayerDBusStubAdapter(void) {
    CommonAPI::DBus::DBusFactory::registerAdapterFactoryMethod(Player::getInterfaceId(),
                                                               &createPlayerDBusStubAdapter);
}

PlayerDBusStubAdapter::PlayerDBusStubAdapter(
        const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
        const std::string& commonApiAddress,
        const std::string& dbusInterfaceName,
        const std::string& dbusBusName,
        const std::string& dbusObjectPath,
        const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusConnection,
        const std::shared_ptr<CommonAPI::StubBase>& stub):
        PlayerDBusStubAdapterHelper(factory, commonApiAddress, dbusInterfaceName, dbusBusName, dbusObjectPath, 
            dbusConnection, std::dynamic_pointer_cast<PlayerStub>(stub),
            false) {
}

PlayerDBusStubAdapter::~PlayerDBusStubAdapter() {
    deactivateManagedInstances();
    deinit();
    stub_.reset();
}

void PlayerDBusStubAdapter::deactivateManagedInstances() {
}

const char* PlayerDBusStubAdapter::getMethodsDBusIntrospectionXmlData() const {
    static const char* introspectionData =
        "<method name=\"getMuteAttribute\">\n"
            "<arg name=\"value\" type=\"i\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"setMuteAttribute\">\n"
            "<arg name=\"requestedValue\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"setValue\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        "<signal name=\"onMuteAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"i\" />\n"
        "</signal>\n"
        "<method name=\"getShuffleAttribute\">\n"
            "<arg name=\"value\" type=\"i\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"setShuffleAttribute\">\n"
            "<arg name=\"requestedValue\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"setValue\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        "<signal name=\"onShuffleAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"i\" />\n"
        "</signal>\n"
        "<method name=\"getRepeatAttribute\">\n"
            "<arg name=\"value\" type=\"i\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"setRepeatAttribute\">\n"
            "<arg name=\"requestedValue\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"setValue\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        "<signal name=\"onRepeatAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"i\" />\n"
        "</signal>\n"
        "<method name=\"getRateAttribute\">\n"
            "<arg name=\"value\" type=\"i\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"setRateAttribute\">\n"
            "<arg name=\"requestedValue\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"setValue\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        "<signal name=\"onRateAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"i\" />\n"
        "</signal>\n"
        "<method name=\"getVolumeAttribute\">\n"
            "<arg name=\"value\" type=\"d\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"setVolumeAttribute\">\n"
            "<arg name=\"requestedValue\" type=\"d\" direction=\"in\" />\n"
            "<arg name=\"setValue\" type=\"d\" direction=\"out\" />\n"
        "</method>\n"
        "<signal name=\"onVolumeAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"d\" />\n"
        "</signal>\n"
        "<method name=\"getCanGoNextAttribute\">\n"
            "<arg name=\"value\" type=\"b\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onCanGoNextAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"b\" />\n"
        "</signal>\n"
        "<method name=\"getCanGoPreviousAttribute\">\n"
            "<arg name=\"value\" type=\"b\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onCanGoPreviousAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"b\" />\n"
        "</signal>\n"
        "<method name=\"getCanPauseAttribute\">\n"
            "<arg name=\"value\" type=\"b\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onCanPauseAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"b\" />\n"
        "</signal>\n"
        "<method name=\"getCanPlayAttribute\">\n"
            "<arg name=\"value\" type=\"b\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onCanPlayAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"b\" />\n"
        "</signal>\n"
        "<method name=\"getCanSeekAttribute\">\n"
            "<arg name=\"value\" type=\"b\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onCanSeekAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"b\" />\n"
        "</signal>\n"
        "<method name=\"getCurrentTrackAttribute\">\n"
            "<arg name=\"value\" type=\"t\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onCurrentTrackAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"t\" />\n"
        "</signal>\n"
        "<method name=\"getPlaybackStatusAttribute\">\n"
            "<arg name=\"value\" type=\"i\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onPlaybackStatusAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"i\" />\n"
        "</signal>\n"
        "<method name=\"getPositionAttribute\">\n"
            "<arg name=\"value\" type=\"t\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"getDurationAttribute\">\n"
            "<arg name=\"value\" type=\"t\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onDurationAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"t\" />\n"
        "</signal>\n"
        /**
         * Skip to the next track in the play queue. If there is no
                              
         *  next track, playback is stopped. If playback is paused or
                            
         *    stopped, this function will set the next plack to be
                              
         *  played once playback is activated
         */
        "<method name=\"next\">\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Open the supplied Uri for playback in the playback engine.
                 returns:
         *  INVALID_URI When an invalid URI is supplied
                                      
         *  (decided by playback engine)
                           NO_ERROR    On success
         * @param uri URI of media to play, uri format is decided by backend
         */
        "<method name=\"openUri\">\n"
            "<arg name=\"uri\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Enqueue the supplied Uri for playback in the playback engine.
                 returns:
         *  INVALID_URI When an invalid URI is supplied
                                      
         *  (decided by playback engine)
                          NO_ERROR    On success
         * @param uri URI of media to enqueue, uri format is decided by backend
         */
        "<method name=\"enqueueUri\">\n"
            "<arg name=\"uri\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Dequeue the item with the supplied index in the playback
                             
         *  engine.
         * @param pos index of media to dequeue
         */
        "<method name=\"dequeueIndex\">\n"
            "<arg name=\"pos\" type=\"t\" direction=\"in\" />\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Retrieve the current play queue in JSON format
                 returns: Current play
         *  queue in JSON format
         */
        "<method name=\"getCurrentPlayQueue\">\n"
            "<arg name=\"playQueue\" type=\"s\" direction=\"out\" />\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Dequeue all elements, emptying the play queue
         */
        "<method name=\"dequeueAll\">\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Use the supplied playlist as the current play queue. If
                             
         *  the play queue is invalid, the old play queue is
                             
         *  untouched.
                 returns: BAD_PLAYLIST If playlist can not be loaded
              
         *              NO_ERROR     On success
         */
        "<method name=\"openPlaylist\">\n"
            "<arg name=\"uri\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Pause playback in the playback engine.
                               If already
         *  paused, this has no effect
                               Note: If CanPause is false,
         *  this has no effect
         */
        "<method name=\"pause\">\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Start or resume playback in the playback engine.
                               If
         *  playback is already commencing, this has not effect.
                               If
         *  paused, playback resumes from the current position.
                               If
         *  there is no track to play, calling this has no effect
                              
         *  Note: If CanPlay is false, this has no effect
         */
        "<method name=\"play\">\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Starts playback (see Play) if paused
                              Pauses playback (see
         *  Pause) is playing
         */
        "<method name=\"playPause\">\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Loads previous track in play queue
                              If there is no
         *  previous track, playback is stopped
                              If playback is
         *  stopped or paused, it remains this way,
                              but the next
         *  track to be played will the set
                              by this function
               
         *                Note: If CanGoPrevious is false, this has no effect
         */
        "<method name=\"previous\">\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Seek relatively in the current track
                              If a negative seek
         *  leads to a play position less than 0,
                              the play position
         *  will be set to 0.
                              If a positive seek leads outside the
         *  length of the current
                              track, this is treated like a call
         *  to Next()
                              Note: If CanSeek is false, this has no effect
         * @param pos Relative seek amount in microseconds
         */
        "<method name=\"seek\">\n"
            "<arg name=\"pos\" type=\"x\" direction=\"in\" />\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Jump to the specified position in the current
                               If the
         *  position is not within range of the current track,
                               do
         *  nothing
                 Note: If CanSeek is false, this has no effect
         * @param pos Absolute position in microseconds
         */
        "<method name=\"setPosition\">\n"
            "<arg name=\"pos\" type=\"t\" direction=\"in\" />\n"
            "<arg name=\"e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        
    ;
    return introspectionData;
}


/**
 * Mute or unmute audio. When muted, the player backend will
                     
 *  not produce any audio output.
 */
static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        PlayerTypes::MuteStatus
        > getMuteAttributeStubDispatcher(&PlayerStub::getMuteAttribute, "i");
static CommonAPI::DBus::DBusSetObservableAttributeStubDispatcher<
        PlayerStub,
        PlayerTypes::MuteStatus
        > setMuteAttributeStubDispatcher(
                &PlayerStub::getMuteAttribute,
                &PlayerStubRemoteEvent::onRemoteSetMuteAttribute,
                &PlayerStubRemoteEvent::onRemoteMuteAttributeChanged,
                &PlayerStubAdapter::fireMuteAttributeChanged,
                "i");

/**
 * Shuffle or unshuffle the current play queue. Shuffling,
                  
 *  un-shuffling and then re-shuffling will yield two different
                  
 *  shufflings (which are not guaranteed to be different)
 */
static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        PlayerTypes::ShuffleStatus
        > getShuffleAttributeStubDispatcher(&PlayerStub::getShuffleAttribute, "i");
static CommonAPI::DBus::DBusSetObservableAttributeStubDispatcher<
        PlayerStub,
        PlayerTypes::ShuffleStatus
        > setShuffleAttributeStubDispatcher(
                &PlayerStub::getShuffleAttribute,
                &PlayerStubRemoteEvent::onRemoteSetShuffleAttribute,
                &PlayerStubRemoteEvent::onRemoteShuffleAttributeChanged,
                &PlayerStubAdapter::fireShuffleAttributeChanged,
                "i");

/**
 * Toggle repeat for the current playlist. If enabled,
                     
 *  playback will continue with the first item of the current
                    
 *   play queue when the last item has finished playing
 */
static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        PlayerTypes::RepeatStatus
        > getRepeatAttributeStubDispatcher(&PlayerStub::getRepeatAttribute, "i");
static CommonAPI::DBus::DBusSetObservableAttributeStubDispatcher<
        PlayerStub,
        PlayerTypes::RepeatStatus
        > setRepeatAttributeStubDispatcher(
                &PlayerStub::getRepeatAttribute,
                &PlayerStubRemoteEvent::onRemoteSetRepeatAttribute,
                &PlayerStubRemoteEvent::onRemoteRepeatAttributeChanged,
                &PlayerStubAdapter::fireRepeatAttributeChanged,
                "i");

/**
 * Set the playback rate
 */
static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        PlayerTypes::RateStatus
        > getRateAttributeStubDispatcher(&PlayerStub::getRateAttribute, "i");
static CommonAPI::DBus::DBusSetObservableAttributeStubDispatcher<
        PlayerStub,
        PlayerTypes::RateStatus
        > setRateAttributeStubDispatcher(
                &PlayerStub::getRateAttribute,
                &PlayerStubRemoteEvent::onRemoteSetRateAttribute,
                &PlayerStubRemoteEvent::onRemoteRateAttributeChanged,
                &PlayerStubAdapter::fireRateAttributeChanged,
                "i");

/**
 * Get or set volume, 0 is muted, and 1.0 means maximum
                     
 *  volume. Values outside this range will be capped
 */
static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        double
        > getVolumeAttributeStubDispatcher(&PlayerStub::getVolumeAttribute, "d");
static CommonAPI::DBus::DBusSetObservableAttributeStubDispatcher<
        PlayerStub,
        double
        > setVolumeAttributeStubDispatcher(
                &PlayerStub::getVolumeAttribute,
                &PlayerStubRemoteEvent::onRemoteSetVolumeAttribute,
                &PlayerStubRemoteEvent::onRemoteVolumeAttributeChanged,
                &PlayerStubAdapter::fireVolumeAttributeChanged,
                "d");

/**
 * Indicates whether Next() is available
 */
static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        bool
        > getCanGoNextAttributeStubDispatcher(&PlayerStub::getCanGoNextAttribute, "b");

/**
 * Indicates whether Previous() is available
 */
static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        bool
        > getCanGoPreviousAttributeStubDispatcher(&PlayerStub::getCanGoPreviousAttribute, "b");

/**
 * Indicates whether Pause() is available
 */
static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        bool
        > getCanPauseAttributeStubDispatcher(&PlayerStub::getCanPauseAttribute, "b");

/**
 * Indicates whether Play() is available
 */
static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        bool
        > getCanPlayAttributeStubDispatcher(&PlayerStub::getCanPlayAttribute, "b");

/**
 * Indicates whether Seek and SetPosition() are available
 */
static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        bool
        > getCanSeekAttributeStubDispatcher(&PlayerStub::getCanSeekAttribute, "b");

/**
 * Indicates the index in the play queue of the currently
                     
 *  playing track
 */
static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        uint64_t
        > getCurrentTrackAttributeStubDispatcher(&PlayerStub::getCurrentTrackAttribute, "t");

/**
 * Indicates current playback status
 */
static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        PlayerTypes::PlaybackStatus
        > getPlaybackStatusAttributeStubDispatcher(&PlayerStub::getPlaybackStatusAttribute, "i");

/**
 * Indicates current position in the currently playing
                      track
 */
static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        uint64_t
        > getPositionAttributeStubDispatcher(&PlayerStub::getPositionAttribute, "t");

/**
 * Indicates duration of the current track
 */
static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        PlayerStub,
        uint64_t
        > getDurationAttributeStubDispatcher(&PlayerStub::getDurationAttribute, "t");


/**
 * Skip to the next track in the play queue. If there is no
                      
 *  next track, playback is stopped. If playback is paused or
                    
 *    stopped, this function will set the next plack to be
                      
 *  played once playback is activated
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<>,
    std::tuple<PlayerTypes::PlayerError>
    > nextStubDispatcher(&PlayerStub::next, "i");
/**
 * Open the supplied Uri for playback in the playback engine.
         returns:
 *  INVALID_URI When an invalid URI is supplied
                              
 *  (decided by playback engine)
                   NO_ERROR    On success
 * @param uri URI of media to play, uri format is decided by backend
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<std::string>,
    std::tuple<PlayerTypes::PlayerError>
    > openUriStubDispatcher(&PlayerStub::openUri, "i");
/**
 * Enqueue the supplied Uri for playback in the playback engine.
         returns:
 *  INVALID_URI When an invalid URI is supplied
                              
 *  (decided by playback engine)
                  NO_ERROR    On success
 * @param uri URI of media to enqueue, uri format is decided by backend
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<std::string>,
    std::tuple<PlayerTypes::PlayerError>
    > enqueueUriStubDispatcher(&PlayerStub::enqueueUri, "i");
/**
 * Dequeue the item with the supplied index in the playback
                     
 *  engine.
 * @param pos index of media to dequeue
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<uint64_t>,
    std::tuple<PlayerTypes::PlayerError>
    > dequeueIndexStubDispatcher(&PlayerStub::dequeueIndex, "i");
/**
 * Retrieve the current play queue in JSON format
         returns: Current play
 *  queue in JSON format
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<>,
    std::tuple<std::string, PlayerTypes::PlayerError>
    > getCurrentPlayQueueStubDispatcher(&PlayerStub::getCurrentPlayQueue, "si");
/**
 * Dequeue all elements, emptying the play queue
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<>,
    std::tuple<PlayerTypes::PlayerError>
    > dequeueAllStubDispatcher(&PlayerStub::dequeueAll, "i");
/**
 * Use the supplied playlist as the current play queue. If
                     
 *  the play queue is invalid, the old play queue is
                     
 *  untouched.
         returns: BAD_PLAYLIST If playlist can not be loaded
      
 *              NO_ERROR     On success
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<std::string>,
    std::tuple<PlayerTypes::PlayerError>
    > openPlaylistStubDispatcher(&PlayerStub::openPlaylist, "i");
/**
 * Pause playback in the playback engine.
                       If already
 *  paused, this has no effect
                       Note: If CanPause is false,
 *  this has no effect
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<>,
    std::tuple<PlayerTypes::PlayerError>
    > pauseStubDispatcher(&PlayerStub::pause, "i");
/**
 * Start or resume playback in the playback engine.
                       If
 *  playback is already commencing, this has not effect.
                       If
 *  paused, playback resumes from the current position.
                       If
 *  there is no track to play, calling this has no effect
                      
 *  Note: If CanPlay is false, this has no effect
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<>,
    std::tuple<PlayerTypes::PlayerError>
    > playStubDispatcher(&PlayerStub::play, "i");
/**
 * Starts playback (see Play) if paused
                      Pauses playback (see
 *  Pause) is playing
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<>,
    std::tuple<PlayerTypes::PlayerError>
    > playPauseStubDispatcher(&PlayerStub::playPause, "i");
/**
 * Loads previous track in play queue
                      If there is no
 *  previous track, playback is stopped
                      If playback is
 *  stopped or paused, it remains this way,
                      but the next
 *  track to be played will the set
                      by this function
       
 *                Note: If CanGoPrevious is false, this has no effect
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<>,
    std::tuple<PlayerTypes::PlayerError>
    > previousStubDispatcher(&PlayerStub::previous, "i");
/**
 * Seek relatively in the current track
                      If a negative seek
 *  leads to a play position less than 0,
                      the play position
 *  will be set to 0.
                      If a positive seek leads outside the
 *  length of the current
                      track, this is treated like a call
 *  to Next()
                      Note: If CanSeek is false, this has no effect
 * @param pos Relative seek amount in microseconds
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<int64_t>,
    std::tuple<PlayerTypes::PlayerError>
    > seekStubDispatcher(&PlayerStub::seek, "i");
/**
 * Jump to the specified position in the current
                       If the
 *  position is not within range of the current track,
                       do
 *  nothing
         Note: If CanSeek is false, this has no effect
 * @param pos Absolute position in microseconds
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    PlayerStub,
    std::tuple<uint64_t>,
    std::tuple<PlayerTypes::PlayerError>
    > setPositionStubDispatcher(&PlayerStub::setPosition, "i");

/**
 * Mute or unmute audio. When muted, the player backend will
                     
 *  not produce any audio output.
 */
void PlayerDBusStubAdapter::fireMuteAttributeChanged(const PlayerTypes::MuteStatus& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::MuteStatus>>
        ::sendSignal(
            *this,
            "onMuteAttributeChanged",
            "i",
            value
    );
}
/**
 * Shuffle or unshuffle the current play queue. Shuffling,
                  
 *  un-shuffling and then re-shuffling will yield two different
                  
 *  shufflings (which are not guaranteed to be different)
 */
void PlayerDBusStubAdapter::fireShuffleAttributeChanged(const PlayerTypes::ShuffleStatus& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::ShuffleStatus>>
        ::sendSignal(
            *this,
            "onShuffleAttributeChanged",
            "i",
            value
    );
}
/**
 * Toggle repeat for the current playlist. If enabled,
                     
 *  playback will continue with the first item of the current
                    
 *   play queue when the last item has finished playing
 */
void PlayerDBusStubAdapter::fireRepeatAttributeChanged(const PlayerTypes::RepeatStatus& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::RepeatStatus>>
        ::sendSignal(
            *this,
            "onRepeatAttributeChanged",
            "i",
            value
    );
}
/**
 * Set the playback rate
 */
void PlayerDBusStubAdapter::fireRateAttributeChanged(const PlayerTypes::RateStatus& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::RateStatus>>
        ::sendSignal(
            *this,
            "onRateAttributeChanged",
            "i",
            value
    );
}
/**
 * Get or set volume, 0 is muted, and 1.0 means maximum
                     
 *  volume. Values outside this range will be capped
 */
void PlayerDBusStubAdapter::fireVolumeAttributeChanged(const double& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<double>>
        ::sendSignal(
            *this,
            "onVolumeAttributeChanged",
            "d",
            value
    );
}
/**
 * Indicates whether Next() is available
 */
void PlayerDBusStubAdapter::fireCanGoNextAttributeChanged(const bool& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<bool>>
        ::sendSignal(
            *this,
            "onCanGoNextAttributeChanged",
            "b",
            value
    );
}
/**
 * Indicates whether Previous() is available
 */
void PlayerDBusStubAdapter::fireCanGoPreviousAttributeChanged(const bool& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<bool>>
        ::sendSignal(
            *this,
            "onCanGoPreviousAttributeChanged",
            "b",
            value
    );
}
/**
 * Indicates whether Pause() is available
 */
void PlayerDBusStubAdapter::fireCanPauseAttributeChanged(const bool& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<bool>>
        ::sendSignal(
            *this,
            "onCanPauseAttributeChanged",
            "b",
            value
    );
}
/**
 * Indicates whether Play() is available
 */
void PlayerDBusStubAdapter::fireCanPlayAttributeChanged(const bool& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<bool>>
        ::sendSignal(
            *this,
            "onCanPlayAttributeChanged",
            "b",
            value
    );
}
/**
 * Indicates whether Seek and SetPosition() are available
 */
void PlayerDBusStubAdapter::fireCanSeekAttributeChanged(const bool& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<bool>>
        ::sendSignal(
            *this,
            "onCanSeekAttributeChanged",
            "b",
            value
    );
}
/**
 * Indicates the index in the play queue of the currently
                     
 *  playing track
 */
void PlayerDBusStubAdapter::fireCurrentTrackAttributeChanged(const uint64_t& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<uint64_t>>
        ::sendSignal(
            *this,
            "onCurrentTrackAttributeChanged",
            "t",
            value
    );
}
/**
 * Indicates current playback status
 */
void PlayerDBusStubAdapter::firePlaybackStatusAttributeChanged(const PlayerTypes::PlaybackStatus& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlaybackStatus>>
        ::sendSignal(
            *this,
            "onPlaybackStatusAttributeChanged",
            "i",
            value
    );
}
/**
 * Indicates current position in the currently playing
                      track
 */
/**
 * Indicates duration of the current track
 */
void PlayerDBusStubAdapter::fireDurationAttributeChanged(const uint64_t& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<uint64_t>>
        ::sendSignal(
            *this,
            "onDurationAttributeChanged",
            "t",
            value
    );
}


const PlayerDBusStubAdapter::StubDispatcherTable& PlayerDBusStubAdapter::getStubDispatcherTable() {
    static const PlayerDBusStubAdapter::StubDispatcherTable stubDispatcherTable = {
            /**
             * Mute or unmute audio. When muted, the player backend will
                                 
             *  not produce any audio output.
             */
            { { "getMuteAttribute", "" }, &org::genivi::mediamanager::getMuteAttributeStubDispatcher }
            , { { "setMuteAttribute", "i" }, &org::genivi::mediamanager::setMuteAttributeStubDispatcher },
            /**
             * Shuffle or unshuffle the current play queue. Shuffling,
                              
             *  un-shuffling and then re-shuffling will yield two different
                              
             *  shufflings (which are not guaranteed to be different)
             */
            { { "getShuffleAttribute", "" }, &org::genivi::mediamanager::getShuffleAttributeStubDispatcher }
            , { { "setShuffleAttribute", "i" }, &org::genivi::mediamanager::setShuffleAttributeStubDispatcher },
            /**
             * Toggle repeat for the current playlist. If enabled,
                                 
             *  playback will continue with the first item of the current
                                
             *   play queue when the last item has finished playing
             */
            { { "getRepeatAttribute", "" }, &org::genivi::mediamanager::getRepeatAttributeStubDispatcher }
            , { { "setRepeatAttribute", "i" }, &org::genivi::mediamanager::setRepeatAttributeStubDispatcher },
            /**
             * Set the playback rate
             */
            { { "getRateAttribute", "" }, &org::genivi::mediamanager::getRateAttributeStubDispatcher }
            , { { "setRateAttribute", "i" }, &org::genivi::mediamanager::setRateAttributeStubDispatcher },
            /**
             * Get or set volume, 0 is muted, and 1.0 means maximum
                                 
             *  volume. Values outside this range will be capped
             */
            { { "getVolumeAttribute", "" }, &org::genivi::mediamanager::getVolumeAttributeStubDispatcher }
            , { { "setVolumeAttribute", "d" }, &org::genivi::mediamanager::setVolumeAttributeStubDispatcher },
            /**
             * Indicates whether Next() is available
             */
            { { "getCanGoNextAttribute", "" }, &org::genivi::mediamanager::getCanGoNextAttributeStubDispatcher },
            /**
             * Indicates whether Previous() is available
             */
            { { "getCanGoPreviousAttribute", "" }, &org::genivi::mediamanager::getCanGoPreviousAttributeStubDispatcher },
            /**
             * Indicates whether Pause() is available
             */
            { { "getCanPauseAttribute", "" }, &org::genivi::mediamanager::getCanPauseAttributeStubDispatcher },
            /**
             * Indicates whether Play() is available
             */
            { { "getCanPlayAttribute", "" }, &org::genivi::mediamanager::getCanPlayAttributeStubDispatcher },
            /**
             * Indicates whether Seek and SetPosition() are available
             */
            { { "getCanSeekAttribute", "" }, &org::genivi::mediamanager::getCanSeekAttributeStubDispatcher },
            /**
             * Indicates the index in the play queue of the currently
                                 
             *  playing track
             */
            { { "getCurrentTrackAttribute", "" }, &org::genivi::mediamanager::getCurrentTrackAttributeStubDispatcher },
            /**
             * Indicates current playback status
             */
            { { "getPlaybackStatusAttribute", "" }, &org::genivi::mediamanager::getPlaybackStatusAttributeStubDispatcher },
            /**
             * Indicates current position in the currently playing
                                  track
             */
            { { "getPositionAttribute", "" }, &org::genivi::mediamanager::getPositionAttributeStubDispatcher },
            /**
             * Indicates duration of the current track
             */
            { { "getDurationAttribute", "" }, &org::genivi::mediamanager::getDurationAttributeStubDispatcher }
            ,
            /**
             * Skip to the next track in the play queue. If there is no
                                  
             *  next track, playback is stopped. If playback is paused or
                                
             *    stopped, this function will set the next plack to be
                                  
             *  played once playback is activated
             */
            { { "next", "" }, &org::genivi::mediamanager::nextStubDispatcher },
            /**
             * Open the supplied Uri for playback in the playback engine.
                     returns:
             *  INVALID_URI When an invalid URI is supplied
                                          
             *  (decided by playback engine)
                               NO_ERROR    On success
             * @param uri URI of media to play, uri format is decided by backend
             */
            { { "openUri", "s" }, &org::genivi::mediamanager::openUriStubDispatcher },
            /**
             * Enqueue the supplied Uri for playback in the playback engine.
                     returns:
             *  INVALID_URI When an invalid URI is supplied
                                          
             *  (decided by playback engine)
                              NO_ERROR    On success
             * @param uri URI of media to enqueue, uri format is decided by backend
             */
            { { "enqueueUri", "s" }, &org::genivi::mediamanager::enqueueUriStubDispatcher },
            /**
             * Dequeue the item with the supplied index in the playback
                                 
             *  engine.
             * @param pos index of media to dequeue
             */
            { { "dequeueIndex", "t" }, &org::genivi::mediamanager::dequeueIndexStubDispatcher },
            /**
             * Retrieve the current play queue in JSON format
                     returns: Current play
             *  queue in JSON format
             */
            { { "getCurrentPlayQueue", "" }, &org::genivi::mediamanager::getCurrentPlayQueueStubDispatcher },
            /**
             * Dequeue all elements, emptying the play queue
             */
            { { "dequeueAll", "" }, &org::genivi::mediamanager::dequeueAllStubDispatcher },
            /**
             * Use the supplied playlist as the current play queue. If
                                 
             *  the play queue is invalid, the old play queue is
                                 
             *  untouched.
                     returns: BAD_PLAYLIST If playlist can not be loaded
                  
             *              NO_ERROR     On success
             */
            { { "openPlaylist", "s" }, &org::genivi::mediamanager::openPlaylistStubDispatcher },
            /**
             * Pause playback in the playback engine.
                                   If already
             *  paused, this has no effect
                                   Note: If CanPause is false,
             *  this has no effect
             */
            { { "pause", "" }, &org::genivi::mediamanager::pauseStubDispatcher },
            /**
             * Start or resume playback in the playback engine.
                                   If
             *  playback is already commencing, this has not effect.
                                   If
             *  paused, playback resumes from the current position.
                                   If
             *  there is no track to play, calling this has no effect
                                  
             *  Note: If CanPlay is false, this has no effect
             */
            { { "play", "" }, &org::genivi::mediamanager::playStubDispatcher },
            /**
             * Starts playback (see Play) if paused
                                  Pauses playback (see
             *  Pause) is playing
             */
            { { "playPause", "" }, &org::genivi::mediamanager::playPauseStubDispatcher },
            /**
             * Loads previous track in play queue
                                  If there is no
             *  previous track, playback is stopped
                                  If playback is
             *  stopped or paused, it remains this way,
                                  but the next
             *  track to be played will the set
                                  by this function
                   
             *                Note: If CanGoPrevious is false, this has no effect
             */
            { { "previous", "" }, &org::genivi::mediamanager::previousStubDispatcher },
            /**
             * Seek relatively in the current track
                                  If a negative seek
             *  leads to a play position less than 0,
                                  the play position
             *  will be set to 0.
                                  If a positive seek leads outside the
             *  length of the current
                                  track, this is treated like a call
             *  to Next()
                                  Note: If CanSeek is false, this has no effect
             * @param pos Relative seek amount in microseconds
             */
            { { "seek", "x" }, &org::genivi::mediamanager::seekStubDispatcher },
            /**
             * Jump to the specified position in the current
                                   If the
             *  position is not within range of the current track,
                                   do
             *  nothing
                     Note: If CanSeek is false, this has no effect
             * @param pos Absolute position in microseconds
             */
            { { "setPosition", "t" }, &org::genivi::mediamanager::setPositionStubDispatcher }
            };
    return stubDispatcherTable;
}


} // namespace mediamanager
} // namespace genivi
} // namespace org
