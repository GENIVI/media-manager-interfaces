/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core Unknown.
* Used org.franca.core Unknown.
*
* 
*/
#ifndef ORG_GENIVI_MEDIAMANAGER_Browser_PROXY_H_
#define ORG_GENIVI_MEDIAMANAGER_Browser_PROXY_H_

#include "BrowserProxyBase.h"


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif


#undef COMMONAPI_INTERNAL_COMPILATION

namespace org {
namespace genivi {
namespace mediamanager {

template <typename ... _AttributeExtensions>
class BrowserProxy: virtual public Browser, virtual public BrowserProxyBase
, public _AttributeExtensions... {
public:
    BrowserProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~BrowserProxy();

    typedef Browser InterfaceType;




    /**
     * Return a list of all media manager identifiers. These are
             used to
     *  indicate which media manager we should interact with.
             returns: A list
     *  of all media managers found
     * 
     * Calls discoverMediaManagers with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void discoverMediaManagers(CommonAPI::CallStatus& callStatus, std::vector<std::string>& identifiers, BrowserTypes::BrowserError& e);
    /**
     * Calls discoverMediaManagers with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> discoverMediaManagersAsync(DiscoverMediaManagersAsyncCallback callback);
    /**
     * List all containers below the given path.
             returns: ResultMapList of
     *  all containers with the given path as parent.
             	   	  See
     *  MediaTypes.fidl for a list of allowed keys.
             errors: NO_CONNECTION if
     *  no connection can be established to underlying
                     browsing
     *  engine
                     BAD_PATH if path parameter is invalid
     * @param path The path to search for containers. The format of the path
                   
     *  depends on the underlying browsing backend
     * @param offset: The offset to use for indexing the results list
     * @param count: The number of results to return, starting from offset
     * @param filter: Array of keys to include in resulting ResultMapList
     * 
     * Calls listContainers with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void listContainers(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, CommonAPI::CallStatus& callStatus, MediaTypes::ResultMapList& m, BrowserTypes::BrowserError& e);
    /**
     * Calls listContainers with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> listContainersAsync(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, ListContainersAsyncCallback callback);
    /**
     * Extends ListContainers with sorting capabilities
     * @param sortKey Key to sort ResultMapList on
     * 
     * Calls listContainersEx with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void listContainersEx(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, const BrowserTypes::SortKey& sortKey, CommonAPI::CallStatus& callStatus, MediaTypes::ResultMapList& m, BrowserTypes::BrowserError& e);
    /**
     * Calls listContainersEx with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> listContainersExAsync(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, const BrowserTypes::SortKey& sortKey, ListContainersExAsyncCallback callback);
    /**
     * List all items in the given container
             returns: A ResultMapList of all
     *  items with the given container as parent.
             		  See MediaTypes.fidl for
     *  a list of allowed keys.
             errors: NO_CONNECTION if no connection can be
     *  established to underlying
                     browsing engine
                    
     *  BAD_PATH if path parameter is invalid
     * @param path The path of the container to search for items.
                    The format
     *  of the path depends on the underlying browsing
                    backend
     * @param offset: The offset to use for indexing the results list
     * @param count: The number of results to return, starting from offset
     * @param filter: Array of keys to include in resulting ResultMapList
     * 
     * Calls listItems with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void listItems(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, CommonAPI::CallStatus& callStatus, MediaTypes::ResultMapList& m, BrowserTypes::BrowserError& e);
    /**
     * Calls listItems with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> listItemsAsync(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, ListItemsAsyncCallback callback);
    /**
     * Extends ListItems with sorting capabilities
     * @param sortKey Key to sort ResultMapList
     * 
     * Calls listItemsEx with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void listItemsEx(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, const BrowserTypes::SortKey& sortKey, CommonAPI::CallStatus& callStatus, MediaTypes::ResultMapList& m, BrowserTypes::BrowserError& e);
    /**
     * Calls listItemsEx with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> listItemsExAsync(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, const BrowserTypes::SortKey& sortKey, ListItemsExAsyncCallback callback);
    /**
     * List all children in the given container
             returns: A ResultMapList of
     *  all children with the given container as parent.
             		  See
     *  MediaTypes.fidl for a list of allowed keys.
             errors: NO_CONNECTION if
     *  no connection can be established to underlying
                      browsing
     *  engine
                      BAD_PATH if path parameter is invalid
     * @param path The path of the container to search for children.
                    The
     *  format of the path depends on the underlying browsing
                    backend
     * @param offset: The offset to use for indexing the results list
     * @param count: The number of results to return, starting from offset
     * @param filter: Array of keys to include in resulting ResultMapList
     * 
     * Calls listChildren with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void listChildren(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, CommonAPI::CallStatus& callStatus, MediaTypes::ResultMapList& m, BrowserTypes::BrowserError& e);
    /**
     * Calls listChildren with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> listChildrenAsync(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, ListChildrenAsyncCallback callback);
    /**
     * Extends ListChildren with sorting capabilities
     * @param sortKey Key to sort ResultMapList on
     * 
     * Calls listChildrenEx with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void listChildrenEx(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, const BrowserTypes::SortKey& sortKey, CommonAPI::CallStatus& callStatus, MediaTypes::ResultMapList& m, BrowserTypes::BrowserError& e);
    /**
     * Calls listChildrenEx with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> listChildrenExAsync(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, const BrowserTypes::SortKey& sortKey, ListChildrenExAsyncCallback callback);
    /**
     * Search for children in the given container
             returns: A ResultMapList of
     *  all children matching the search criteria with
                       the given
     *  container as parent.See MediaTypes.fidl for a list of
                      
     *  allowed keys.
             errors: NO_CONNECTION if no connection can be
     *  established to underlying
                     browsing engine
                    
     *  BAD_PATH if path parameter is invalid
     * @param path The path of the container to search for children.
                    The
     *  format of the path depends on the underlying browsing
                    backend
     * @param query Search query to match children against. The format of the
                   
     *  query depends on the underlying browsing backend
     * @param offset: The offset to use for indexing the results list
     * @param count: The number of results to return, starting from offset
     * @param filter: Array of keys to include in resulting ResultMapList
     * 
     * Calls searchObjects with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void searchObjects(const std::string& path, const std::string& query, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, CommonAPI::CallStatus& callStatus, MediaTypes::ResultMapList& m, BrowserTypes::BrowserError& e);
    /**
     * Calls searchObjects with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> searchObjectsAsync(const std::string& path, const std::string& query, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, SearchObjectsAsyncCallback callback);
    /**
     * Extends SearchObjects with sorting capabilities
     * @param sortKey Key to sort ResultMapList on
     * 
     * Calls searchObjectsEx with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void searchObjectsEx(const std::string& path, const std::string& query, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, const BrowserTypes::SortKey& sortKey, CommonAPI::CallStatus& callStatus, MediaTypes::ResultMapList& m, BrowserTypes::BrowserError& e);
    /**
     * Calls searchObjectsEx with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> searchObjectsExAsync(const std::string& path, const std::string& query, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, const BrowserTypes::SortKey& sortKey, SearchObjectsExAsyncCallback callback);
    /**
     * Get a list of all initial letters and their index in the
                         
     *  given container
             returns: A list of tuples of initial letters and
     *  their first
                       observed position when sorting according to
     *  sortKey
             errors: NO_CONNECTION if no connection can be established to
     *  underlying
                     browsing engine
                     BAD_PATH if path
     *  parameter is invalid
     * @param container: Container to build index list for
     * @param count: How many (unsorted) items should be traversed to build
                     
     *         index
     * @param filter: List of initial letters to include
     * @param sortKey: Key to sort on when building index list
     * 
     * Calls listIndexes with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void listIndexes(const std::string& container, const uint64_t& count, const std::vector<std::string>& filter, const BrowserTypes::SortKey& sortKey, CommonAPI::CallStatus& callStatus, std::string& indexes, BrowserTypes::BrowserError& e);
    /**
     * Calls listIndexes with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> listIndexesAsync(const std::string& container, const uint64_t& count, const std::vector<std::string>& filter, const BrowserTypes::SortKey& sortKey, ListIndexesAsyncCallback callback);
    /**
     * Create a new empty container with path used as root
             returns: Path
     *  identifier for the newly created container
             errors: NO_CONNECTION if
     *  no connection can be established to underlying
                      browsing
     *  engine
                      BAD_PATH if path parameter is invalid
     * @param path: Path to place the newly created container in
     * @param displayName: Display name for the new container
     * @param childTypes: Array of allowed types on children in new container
     * 
     * Calls createContainer with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void createContainer(const std::string& path, const std::string& displayName, const std::vector<std::string>& childTypes, CommonAPI::CallStatus& callStatus, std::string& pathIdentifier, BrowserTypes::BrowserError& e);
    /**
     * Calls createContainer with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> createContainerAsync(const std::string& path, const std::string& displayName, const std::vector<std::string>& childTypes, CreateContainerAsyncCallback callback);
    /**
     * Place a reference in a container, pointing to an object
             returns: Path
     *  identifier for the container containing the reference
             errors:
     *  NO_CONNECTION if no connection can be established to underlying
                  
     *     browsing engine
                      BAD_PATH if path parameter is invalid
     * @param path: Path to place the newly created container in
     * @param objectPath: Path to object to create reference to
     * 
     * Calls createReference with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void createReference(const std::string& path, const std::string& objectPath, CommonAPI::CallStatus& callStatus, std::string& pathIdentifier, BrowserTypes::BrowserError& e);
    /**
     * Calls createReference with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> createReferenceAsync(const std::string& path, const std::string& objectPath, CreateReferenceAsyncCallback callback);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual std::string getAddress() const;

    /**
     * Returns the domain of the remote partner this proxy communicates with.
     */
    virtual const std::string& getDomain() const;

    /** 
     * Returns the service ID of the remote partner this proxy communicates with.
     */
    virtual const std::string& getServiceId() const;

    /**
     * Returns the instance ID of the remote partner this proxy communicates with.
     */
    virtual const std::string& getInstanceId() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<BrowserProxyBase> delegate_;
};

#ifdef WIN32
    typedef BrowserProxy<CommonAPI::WINDummyAttributeExtension<CommonAPI::WINDummyAttribute>> BrowserProxyDefault;
#else
    typedef BrowserProxy<> BrowserProxyDefault;
#endif


//
// BrowserProxy Implementation
//
template <typename ... _AttributeExtensions>
BrowserProxy<_AttributeExtensions...>::BrowserProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<BrowserProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<BrowserProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
BrowserProxy<_AttributeExtensions...>::~BrowserProxy() {
}

/**
 * Return a list of all media manager identifiers. These are
         used to
 *  indicate which media manager we should interact with.
         returns: A list
 *  of all media managers found
 */
template <typename ... _AttributeExtensions>
void BrowserProxy<_AttributeExtensions...>::discoverMediaManagers(CommonAPI::CallStatus& callStatus, std::vector<std::string>& identifiers, BrowserTypes::BrowserError& e) {
    delegate_->discoverMediaManagers(callStatus, identifiers, e);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BrowserProxy<_AttributeExtensions...>::discoverMediaManagersAsync(DiscoverMediaManagersAsyncCallback callback) {
    return delegate_->discoverMediaManagersAsync(callback);
}
/**
 * List all containers below the given path.
         returns: ResultMapList of
 *  all containers with the given path as parent.
         	   	  See
 *  MediaTypes.fidl for a list of allowed keys.
         errors: NO_CONNECTION if
 *  no connection can be established to underlying
                 browsing
 *  engine
                 BAD_PATH if path parameter is invalid
 * @param path The path to search for containers. The format of the path
               
 *  depends on the underlying browsing backend
 * @param offset: The offset to use for indexing the results list
 * @param count: The number of results to return, starting from offset
 * @param filter: Array of keys to include in resulting ResultMapList
 */
template <typename ... _AttributeExtensions>
void BrowserProxy<_AttributeExtensions...>::listContainers(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, CommonAPI::CallStatus& callStatus, MediaTypes::ResultMapList& m, BrowserTypes::BrowserError& e) {
    delegate_->listContainers(path, offset, count, filter, callStatus, m, e);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BrowserProxy<_AttributeExtensions...>::listContainersAsync(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, ListContainersAsyncCallback callback) {
    return delegate_->listContainersAsync(path, offset, count, filter, callback);
}
/**
 * Extends ListContainers with sorting capabilities
 * @param sortKey Key to sort ResultMapList on
 */
template <typename ... _AttributeExtensions>
void BrowserProxy<_AttributeExtensions...>::listContainersEx(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, const BrowserTypes::SortKey& sortKey, CommonAPI::CallStatus& callStatus, MediaTypes::ResultMapList& m, BrowserTypes::BrowserError& e) {
    delegate_->listContainersEx(path, offset, count, filter, sortKey, callStatus, m, e);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BrowserProxy<_AttributeExtensions...>::listContainersExAsync(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, const BrowserTypes::SortKey& sortKey, ListContainersExAsyncCallback callback) {
    return delegate_->listContainersExAsync(path, offset, count, filter, sortKey, callback);
}
/**
 * List all items in the given container
         returns: A ResultMapList of all
 *  items with the given container as parent.
         		  See MediaTypes.fidl for
 *  a list of allowed keys.
         errors: NO_CONNECTION if no connection can be
 *  established to underlying
                 browsing engine
                
 *  BAD_PATH if path parameter is invalid
 * @param path The path of the container to search for items.
                The format
 *  of the path depends on the underlying browsing
                backend
 * @param offset: The offset to use for indexing the results list
 * @param count: The number of results to return, starting from offset
 * @param filter: Array of keys to include in resulting ResultMapList
 */
template <typename ... _AttributeExtensions>
void BrowserProxy<_AttributeExtensions...>::listItems(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, CommonAPI::CallStatus& callStatus, MediaTypes::ResultMapList& m, BrowserTypes::BrowserError& e) {
    delegate_->listItems(path, offset, count, filter, callStatus, m, e);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BrowserProxy<_AttributeExtensions...>::listItemsAsync(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, ListItemsAsyncCallback callback) {
    return delegate_->listItemsAsync(path, offset, count, filter, callback);
}
/**
 * Extends ListItems with sorting capabilities
 * @param sortKey Key to sort ResultMapList
 */
template <typename ... _AttributeExtensions>
void BrowserProxy<_AttributeExtensions...>::listItemsEx(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, const BrowserTypes::SortKey& sortKey, CommonAPI::CallStatus& callStatus, MediaTypes::ResultMapList& m, BrowserTypes::BrowserError& e) {
    delegate_->listItemsEx(path, offset, count, filter, sortKey, callStatus, m, e);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BrowserProxy<_AttributeExtensions...>::listItemsExAsync(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, const BrowserTypes::SortKey& sortKey, ListItemsExAsyncCallback callback) {
    return delegate_->listItemsExAsync(path, offset, count, filter, sortKey, callback);
}
/**
 * List all children in the given container
         returns: A ResultMapList of
 *  all children with the given container as parent.
         		  See
 *  MediaTypes.fidl for a list of allowed keys.
         errors: NO_CONNECTION if
 *  no connection can be established to underlying
                  browsing
 *  engine
                  BAD_PATH if path parameter is invalid
 * @param path The path of the container to search for children.
                The
 *  format of the path depends on the underlying browsing
                backend
 * @param offset: The offset to use for indexing the results list
 * @param count: The number of results to return, starting from offset
 * @param filter: Array of keys to include in resulting ResultMapList
 */
template <typename ... _AttributeExtensions>
void BrowserProxy<_AttributeExtensions...>::listChildren(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, CommonAPI::CallStatus& callStatus, MediaTypes::ResultMapList& m, BrowserTypes::BrowserError& e) {
    delegate_->listChildren(path, offset, count, filter, callStatus, m, e);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BrowserProxy<_AttributeExtensions...>::listChildrenAsync(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, ListChildrenAsyncCallback callback) {
    return delegate_->listChildrenAsync(path, offset, count, filter, callback);
}
/**
 * Extends ListChildren with sorting capabilities
 * @param sortKey Key to sort ResultMapList on
 */
template <typename ... _AttributeExtensions>
void BrowserProxy<_AttributeExtensions...>::listChildrenEx(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, const BrowserTypes::SortKey& sortKey, CommonAPI::CallStatus& callStatus, MediaTypes::ResultMapList& m, BrowserTypes::BrowserError& e) {
    delegate_->listChildrenEx(path, offset, count, filter, sortKey, callStatus, m, e);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BrowserProxy<_AttributeExtensions...>::listChildrenExAsync(const std::string& path, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, const BrowserTypes::SortKey& sortKey, ListChildrenExAsyncCallback callback) {
    return delegate_->listChildrenExAsync(path, offset, count, filter, sortKey, callback);
}
/**
 * Search for children in the given container
         returns: A ResultMapList of
 *  all children matching the search criteria with
                   the given
 *  container as parent.See MediaTypes.fidl for a list of
                  
 *  allowed keys.
         errors: NO_CONNECTION if no connection can be
 *  established to underlying
                 browsing engine
                
 *  BAD_PATH if path parameter is invalid
 * @param path The path of the container to search for children.
                The
 *  format of the path depends on the underlying browsing
                backend
 * @param query Search query to match children against. The format of the
               
 *  query depends on the underlying browsing backend
 * @param offset: The offset to use for indexing the results list
 * @param count: The number of results to return, starting from offset
 * @param filter: Array of keys to include in resulting ResultMapList
 */
template <typename ... _AttributeExtensions>
void BrowserProxy<_AttributeExtensions...>::searchObjects(const std::string& path, const std::string& query, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, CommonAPI::CallStatus& callStatus, MediaTypes::ResultMapList& m, BrowserTypes::BrowserError& e) {
    delegate_->searchObjects(path, query, offset, count, filter, callStatus, m, e);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BrowserProxy<_AttributeExtensions...>::searchObjectsAsync(const std::string& path, const std::string& query, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, SearchObjectsAsyncCallback callback) {
    return delegate_->searchObjectsAsync(path, query, offset, count, filter, callback);
}
/**
 * Extends SearchObjects with sorting capabilities
 * @param sortKey Key to sort ResultMapList on
 */
template <typename ... _AttributeExtensions>
void BrowserProxy<_AttributeExtensions...>::searchObjectsEx(const std::string& path, const std::string& query, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, const BrowserTypes::SortKey& sortKey, CommonAPI::CallStatus& callStatus, MediaTypes::ResultMapList& m, BrowserTypes::BrowserError& e) {
    delegate_->searchObjectsEx(path, query, offset, count, filter, sortKey, callStatus, m, e);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BrowserProxy<_AttributeExtensions...>::searchObjectsExAsync(const std::string& path, const std::string& query, const uint64_t& offset, const uint64_t& count, const std::vector<std::string>& filter, const BrowserTypes::SortKey& sortKey, SearchObjectsExAsyncCallback callback) {
    return delegate_->searchObjectsExAsync(path, query, offset, count, filter, sortKey, callback);
}
/**
 * Get a list of all initial letters and their index in the
                     
 *  given container
         returns: A list of tuples of initial letters and
 *  their first
                   observed position when sorting according to
 *  sortKey
         errors: NO_CONNECTION if no connection can be established to
 *  underlying
                 browsing engine
                 BAD_PATH if path
 *  parameter is invalid
 * @param container: Container to build index list for
 * @param count: How many (unsorted) items should be traversed to build
                 
 *         index
 * @param filter: List of initial letters to include
 * @param sortKey: Key to sort on when building index list
 */
template <typename ... _AttributeExtensions>
void BrowserProxy<_AttributeExtensions...>::listIndexes(const std::string& container, const uint64_t& count, const std::vector<std::string>& filter, const BrowserTypes::SortKey& sortKey, CommonAPI::CallStatus& callStatus, std::string& indexes, BrowserTypes::BrowserError& e) {
    delegate_->listIndexes(container, count, filter, sortKey, callStatus, indexes, e);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BrowserProxy<_AttributeExtensions...>::listIndexesAsync(const std::string& container, const uint64_t& count, const std::vector<std::string>& filter, const BrowserTypes::SortKey& sortKey, ListIndexesAsyncCallback callback) {
    return delegate_->listIndexesAsync(container, count, filter, sortKey, callback);
}
/**
 * Create a new empty container with path used as root
         returns: Path
 *  identifier for the newly created container
         errors: NO_CONNECTION if
 *  no connection can be established to underlying
                  browsing
 *  engine
                  BAD_PATH if path parameter is invalid
 * @param path: Path to place the newly created container in
 * @param displayName: Display name for the new container
 * @param childTypes: Array of allowed types on children in new container
 */
template <typename ... _AttributeExtensions>
void BrowserProxy<_AttributeExtensions...>::createContainer(const std::string& path, const std::string& displayName, const std::vector<std::string>& childTypes, CommonAPI::CallStatus& callStatus, std::string& pathIdentifier, BrowserTypes::BrowserError& e) {
    delegate_->createContainer(path, displayName, childTypes, callStatus, pathIdentifier, e);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BrowserProxy<_AttributeExtensions...>::createContainerAsync(const std::string& path, const std::string& displayName, const std::vector<std::string>& childTypes, CreateContainerAsyncCallback callback) {
    return delegate_->createContainerAsync(path, displayName, childTypes, callback);
}
/**
 * Place a reference in a container, pointing to an object
         returns: Path
 *  identifier for the container containing the reference
         errors:
 *  NO_CONNECTION if no connection can be established to underlying
              
 *     browsing engine
                  BAD_PATH if path parameter is invalid
 * @param path: Path to place the newly created container in
 * @param objectPath: Path to object to create reference to
 */
template <typename ... _AttributeExtensions>
void BrowserProxy<_AttributeExtensions...>::createReference(const std::string& path, const std::string& objectPath, CommonAPI::CallStatus& callStatus, std::string& pathIdentifier, BrowserTypes::BrowserError& e) {
    delegate_->createReference(path, objectPath, callStatus, pathIdentifier, e);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BrowserProxy<_AttributeExtensions...>::createReferenceAsync(const std::string& path, const std::string& objectPath, CreateReferenceAsyncCallback callback) {
    return delegate_->createReferenceAsync(path, objectPath, callback);
}

template <typename ... _AttributeExtensions>
std::string BrowserProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
const std::string& BrowserProxy<_AttributeExtensions...>::getDomain() const {
    return delegate_->getDomain();
}

template <typename ... _AttributeExtensions>
const std::string& BrowserProxy<_AttributeExtensions...>::getServiceId() const {
    return delegate_->getServiceId();
}

template <typename ... _AttributeExtensions>
const std::string& BrowserProxy<_AttributeExtensions...>::getInstanceId() const {
    return delegate_->getInstanceId();
}

template <typename ... _AttributeExtensions>
bool BrowserProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool BrowserProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& BrowserProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& BrowserProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace mediamanager
} // namespace genivi
} // namespace org


#endif // ORG_GENIVI_MEDIAMANAGER_Browser_PROXY_H_
