/*
* This file was generated by the CommonAPI Generators. 
* Used org.genivi.commonapi.core 2.1.4.
* Used org.franca.core 0.8.9.
*
* 
*/
#include "PlayerDBusProxy.h"

namespace org {
namespace genivi {
namespace mediamanager {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createPlayerDBusProxy(
                    const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
                    const std::string& commonApiAddress,
                    const std::string& interfaceName,
                    const std::string& busName,
                    const std::string& objectPath,
                    const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyConnection) {
    return std::make_shared<PlayerDBusProxy>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection);
}

__attribute__((constructor)) void registerPlayerDBusProxy(void) {
    CommonAPI::DBus::DBusFactory::registerProxyFactoryMethod(Player::getInterfaceId(),
       &createPlayerDBusProxy);
}

PlayerDBusProxy::PlayerDBusProxy(
                    const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
                    const std::string& commonApiAddress,
                    const std::string& interfaceName,
                    const std::string& busName,
                    const std::string& objectPath,
                    const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyconnection):
        CommonAPI::DBus::DBusProxy(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyconnection)
,mute_(*this, "onMuteAttributeChanged", "setMuteAttribute", "i", "getMuteAttribute"),
shuffle_(*this, "onShuffleAttributeChanged", "setShuffleAttribute", "i", "getShuffleAttribute"),
repeat_(*this, "onRepeatAttributeChanged", "setRepeatAttribute", "i", "getRepeatAttribute"),
rate_(*this, "onRateAttributeChanged", "setRateAttribute", "i", "getRateAttribute"),
volume_(*this, "onVolumeAttributeChanged", "setVolumeAttribute", "d", "getVolumeAttribute"),
canGoNext_(*this, "onCanGoNextAttributeChanged", "b", "getCanGoNextAttribute"),
canGoPrevious_(*this, "onCanGoPreviousAttributeChanged", "b", "getCanGoPreviousAttribute"),
canPause_(*this, "onCanPauseAttributeChanged", "b", "getCanPauseAttribute"),
canPlay_(*this, "onCanPlayAttributeChanged", "b", "getCanPlayAttribute"),
canSeek_(*this, "onCanSeekAttributeChanged", "b", "getCanSeekAttribute"),
currentTrack_(*this, "onCurrentTrackAttributeChanged", "t", "getCurrentTrackAttribute"),
playbackStatus_(*this, "onPlaybackStatusAttributeChanged", "i", "getPlaybackStatusAttribute"),
position_(*this, "t", "getPositionAttribute"),
duration_(*this, "onDurationAttributeChanged", "t", "getDurationAttribute")
    {
    }

PlayerDBusProxy::MuteAttribute& PlayerDBusProxy::getMuteAttribute() {
    return mute_;
}
PlayerDBusProxy::ShuffleAttribute& PlayerDBusProxy::getShuffleAttribute() {
    return shuffle_;
}
PlayerDBusProxy::RepeatAttribute& PlayerDBusProxy::getRepeatAttribute() {
    return repeat_;
}
PlayerDBusProxy::RateAttribute& PlayerDBusProxy::getRateAttribute() {
    return rate_;
}
PlayerDBusProxy::VolumeAttribute& PlayerDBusProxy::getVolumeAttribute() {
    return volume_;
}
PlayerDBusProxy::CanGoNextAttribute& PlayerDBusProxy::getCanGoNextAttribute() {
    return canGoNext_;
}
PlayerDBusProxy::CanGoPreviousAttribute& PlayerDBusProxy::getCanGoPreviousAttribute() {
    return canGoPrevious_;
}
PlayerDBusProxy::CanPauseAttribute& PlayerDBusProxy::getCanPauseAttribute() {
    return canPause_;
}
PlayerDBusProxy::CanPlayAttribute& PlayerDBusProxy::getCanPlayAttribute() {
    return canPlay_;
}
PlayerDBusProxy::CanSeekAttribute& PlayerDBusProxy::getCanSeekAttribute() {
    return canSeek_;
}
PlayerDBusProxy::CurrentTrackAttribute& PlayerDBusProxy::getCurrentTrackAttribute() {
    return currentTrack_;
}
PlayerDBusProxy::PlaybackStatusAttribute& PlayerDBusProxy::getPlaybackStatusAttribute() {
    return playbackStatus_;
}
PlayerDBusProxy::PositionAttribute& PlayerDBusProxy::getPositionAttribute() {
    return position_;
}
PlayerDBusProxy::DurationAttribute& PlayerDBusProxy::getDurationAttribute() {
    return duration_;
}


/**
 * Skip to the next track in the play queue. If there is no
                      
 *  next track, playback is stopped. If playback is paused or
                    
 *    stopped, this function will set the next plack to be
                      
 *  played once playback is activated
 */
void PlayerDBusProxy::next(CommonAPI::CallStatus& callStatus, PlayerTypes::PlayerError& e) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodWithReply(
        *this,
        "next",
        "",
        callStatus
        , e);
}
std::future<CommonAPI::CallStatus> PlayerDBusProxy::nextAsync(NextAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodAsync(
        *this,
        "next",
        "",
        std::move(callback));
}
/**
 * Open the supplied Uri for playback in the playback engine.
         returns:
 *  INVALID_URI When an invalid URI is supplied
                              
 *  (decided by playback engine)
                   NO_ERROR    On success
 * @param uri URI of media to play, uri format is decided by backend
 */
void PlayerDBusProxy::openUri(const std::string& uri, CommonAPI::CallStatus& callStatus, PlayerTypes::PlayerError& e) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodWithReply(
        *this,
        "openUri",
        "s",
        uri, 
        callStatus
        , e);
}
std::future<CommonAPI::CallStatus> PlayerDBusProxy::openUriAsync(const std::string& uri, OpenUriAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodAsync(
        *this,
        "openUri",
        "s",
        uri, 
        std::move(callback));
}
/**
 * Enqueue the supplied Uri for playback in the playback engine.
         returns:
 *  INVALID_URI When an invalid URI is supplied
                              
 *  (decided by playback engine)
                  NO_ERROR    On success
 * @param uri URI of media to enqueue, uri format is decided by backend
 */
void PlayerDBusProxy::enqueueUri(const std::string& uri, CommonAPI::CallStatus& callStatus, PlayerTypes::PlayerError& e) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodWithReply(
        *this,
        "enqueueUri",
        "s",
        uri, 
        callStatus
        , e);
}
std::future<CommonAPI::CallStatus> PlayerDBusProxy::enqueueUriAsync(const std::string& uri, EnqueueUriAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodAsync(
        *this,
        "enqueueUri",
        "s",
        uri, 
        std::move(callback));
}
/**
 * Dequeue the item with the supplied index in the playback
                     
 *  engine.
 * @param pos index of media to dequeue
 */
void PlayerDBusProxy::dequeueIndex(const uint64_t& pos, CommonAPI::CallStatus& callStatus, PlayerTypes::PlayerError& e) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<uint64_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodWithReply(
        *this,
        "dequeueIndex",
        "t",
        pos, 
        callStatus
        , e);
}
std::future<CommonAPI::CallStatus> PlayerDBusProxy::dequeueIndexAsync(const uint64_t& pos, DequeueIndexAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<uint64_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodAsync(
        *this,
        "dequeueIndex",
        "t",
        pos, 
        std::move(callback));
}
/**
 * Retrieve the current play queue in JSON format
         returns: Current play
 *  queue in JSON format
 */
void PlayerDBusProxy::getCurrentPlayQueue(CommonAPI::CallStatus& callStatus, std::string& playQueue, PlayerTypes::PlayerError& e) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
                                     CommonAPI::DBus::DBusSerializableArguments<std::string, PlayerTypes::PlayerError> >::callMethodWithReply(
        *this,
        "getCurrentPlayQueue",
        "",
        callStatus
        , playQueue, e);
}
std::future<CommonAPI::CallStatus> PlayerDBusProxy::getCurrentPlayQueueAsync(GetCurrentPlayQueueAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
                                     CommonAPI::DBus::DBusSerializableArguments<std::string, PlayerTypes::PlayerError> >::callMethodAsync(
        *this,
        "getCurrentPlayQueue",
        "",
        std::move(callback));
}
/**
 * Dequeue all elements, emptying the play queue
 */
void PlayerDBusProxy::dequeueAll(CommonAPI::CallStatus& callStatus, PlayerTypes::PlayerError& e) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodWithReply(
        *this,
        "dequeueAll",
        "",
        callStatus
        , e);
}
std::future<CommonAPI::CallStatus> PlayerDBusProxy::dequeueAllAsync(DequeueAllAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodAsync(
        *this,
        "dequeueAll",
        "",
        std::move(callback));
}
/**
 * Use the supplied playlist as the current play queue. If
                     
 *  the play queue is invalid, the old play queue is
                     
 *  untouched.
         returns: BAD_PLAYLIST If playlist can not be loaded
      
 *              NO_ERROR     On success
 */
void PlayerDBusProxy::openPlaylist(const std::string& uri, CommonAPI::CallStatus& callStatus, PlayerTypes::PlayerError& e) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodWithReply(
        *this,
        "openPlaylist",
        "s",
        uri, 
        callStatus
        , e);
}
std::future<CommonAPI::CallStatus> PlayerDBusProxy::openPlaylistAsync(const std::string& uri, OpenPlaylistAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodAsync(
        *this,
        "openPlaylist",
        "s",
        uri, 
        std::move(callback));
}
/**
 * Pause playback in the playback engine.
                       If already
 *  paused, this has no effect
                       Note: If CanPause is false,
 *  this has no effect
 */
void PlayerDBusProxy::pause(CommonAPI::CallStatus& callStatus, PlayerTypes::PlayerError& e) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodWithReply(
        *this,
        "pause",
        "",
        callStatus
        , e);
}
std::future<CommonAPI::CallStatus> PlayerDBusProxy::pauseAsync(PauseAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodAsync(
        *this,
        "pause",
        "",
        std::move(callback));
}
/**
 * Start or resume playback in the playback engine.
                       If
 *  playback is already commencing, this has not effect.
                       If
 *  paused, playback resumes from the current position.
                       If
 *  there is no track to play, calling this has no effect
                      
 *  Note: If CanPlay is false, this has no effect
 */
void PlayerDBusProxy::play(CommonAPI::CallStatus& callStatus, PlayerTypes::PlayerError& e) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodWithReply(
        *this,
        "play",
        "",
        callStatus
        , e);
}
std::future<CommonAPI::CallStatus> PlayerDBusProxy::playAsync(PlayAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodAsync(
        *this,
        "play",
        "",
        std::move(callback));
}
/**
 * Starts playback (see Play) if paused
                      Pauses playback (see
 *  Pause) is playing
 */
void PlayerDBusProxy::playPause(CommonAPI::CallStatus& callStatus, PlayerTypes::PlayerError& e) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodWithReply(
        *this,
        "playPause",
        "",
        callStatus
        , e);
}
std::future<CommonAPI::CallStatus> PlayerDBusProxy::playPauseAsync(PlayPauseAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodAsync(
        *this,
        "playPause",
        "",
        std::move(callback));
}
/**
 * Loads previous track in play queue
                      If there is no
 *  previous track, playback is stopped
                      If playback is
 *  stopped or paused, it remains this way,
                      but the next
 *  track to be played will the set
                      by this function
       
 *                Note: If CanGoPrevious is false, this has no effect
 */
void PlayerDBusProxy::previous(CommonAPI::CallStatus& callStatus, PlayerTypes::PlayerError& e) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodWithReply(
        *this,
        "previous",
        "",
        callStatus
        , e);
}
std::future<CommonAPI::CallStatus> PlayerDBusProxy::previousAsync(PreviousAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodAsync(
        *this,
        "previous",
        "",
        std::move(callback));
}
/**
 * Seek relatively in the current track
                      If a negative seek
 *  leads to a play position less than 0,
                      the play position
 *  will be set to 0.
                      If a positive seek leads outside the
 *  length of the current
                      track, this is treated like a call
 *  to Next()
                      Note: If CanSeek is false, this has no effect
 * @param pos Relative seek amount in microseconds
 */
void PlayerDBusProxy::seek(const int64_t& pos, CommonAPI::CallStatus& callStatus, PlayerTypes::PlayerError& e) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<int64_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodWithReply(
        *this,
        "seek",
        "x",
        pos, 
        callStatus
        , e);
}
std::future<CommonAPI::CallStatus> PlayerDBusProxy::seekAsync(const int64_t& pos, SeekAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<int64_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodAsync(
        *this,
        "seek",
        "x",
        pos, 
        std::move(callback));
}
/**
 * Jump to the specified position in the current
                       If the
 *  position is not within range of the current track,
                       do
 *  nothing
         Note: If CanSeek is false, this has no effect
 * @param pos Absolute position in microseconds
 */
void PlayerDBusProxy::setPosition(const uint64_t& pos, CommonAPI::CallStatus& callStatus, PlayerTypes::PlayerError& e) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<uint64_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodWithReply(
        *this,
        "setPosition",
        "t",
        pos, 
        callStatus
        , e);
}
std::future<CommonAPI::CallStatus> PlayerDBusProxy::setPositionAsync(const uint64_t& pos, SetPositionAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<uint64_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<PlayerTypes::PlayerError> >::callMethodAsync(
        *this,
        "setPosition",
        "t",
        pos, 
        std::move(callback));
}



void PlayerDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
    ownVersionMajor = 1;
    ownVersionMinor = 0;
}

} // namespace mediamanager
} // namespace genivi
} // namespace org
